import type {
  JSONSchema7,
  JSONSchema7Definition,
  JSONSchema7Type,
} from "json-schema"
import type { KurtSchema } from "./KurtSchema"
import z from "zod"

type InnerAny = z.ZodTypeAny
type InnerArrayAny = z.ZodArray<InnerAny>
type InnerTupleAny = z.ZodTuple<[InnerAny, ...InnerAny[]], InnerAny | null>

/**
 * Convert a `JSONSchema7` object schema to a `KurtSchema`, dynamically.
 *
 * The resulting KurtSchema will be somewhat weakly typed in TypeScript
 * (the data type is only known to be a `Record` with unknown properties)
 * because the JSON schema is being dynamically loaded at runtime rather than
 * baked into the type system statically as Zod types.
 *
 * However, the underlying LLM will be aware of the actual schema even
 * if TypeScript isn't, and you'll still get runtime validation of the data.
 *
 * This function is useful for highly dynamic cases where you need to load
 * schemas at runtime, from a database, from responses of another service,
 * or even schemas that were generated by an LLM in a previous step.
 */
export function fromJSONSchema7(
  input: JSONSchema7 & { type: "object" }
): KurtSchema<Record<string, InnerAny>> {
  return handleObject(input)
}

function handleDef(input: JSONSchema7Definition): InnerAny {
  if (input === true) return z.any()
  if (input === false) return z.never()

  if (input.enum !== undefined)
    return handleEnum(input as JSONSchema7 & { enum: JSONSchema7Type[] })
  if (input.const !== undefined)
    return handleCommon(input, z.literal(toZodPrimitive(input.const)))

  for (const key of ["if", "then", "else", "not"] as const) {
    if (input[key] !== undefined) throwUnsupported(key)
  }

  if (input.allOf !== undefined)
    return handleIntersection(
      input as JSONSchema7 & { allOf: JSONSchema7Definition[] }
    )
  if (input.anyOf !== undefined)
    return handleUnion(
      input as JSONSchema7 & { anyOf: JSONSchema7Definition[] }
    )
  if (input.oneOf !== undefined)
    throwUnsupported("oneOf", "(only 'anyOf' is supported)")

  switch (input.type) {
    case undefined:
      return handleCommon(input as JSONSchema7, z.any())
    case "null":
      return handleCommon(input as JSONSchema7, z.null())
    case "boolean":
      return handleCommon(input as JSONSchema7, z.boolean())
    case "number":
      return handleNumber(input as JSONSchema7 & { type: "number" })
    case "integer":
      return handleInteger(input as JSONSchema7 & { type: "integer" })
    case "string":
      return handleString(input as JSONSchema7 & { type: "string" })
    case "array":
      return handleArray(input as JSONSchema7 & { type: "array" })
    case "object":
      if (
        input.additionalProperties !== undefined &&
        input.additionalProperties !== false
      )
        return handleRecord(
          input as JSONSchema7 & {
            type: "object"
            additionalProperties: JSONSchema7Definition
          }
        )
      return handleObject(input as JSONSchema7 & { type: "object" })
    default:
      throwUnsupported(JSON.stringify(input.type), "as a type")
  }
}

function handleNumber(input: JSONSchema7 & { type: "number" }): z.ZodNumber {
  let inner = handleCommon(input, z.number().finite())

  if (input.minimum !== undefined) inner = inner.min(input.minimum)
  if (input.maximum !== undefined) inner = inner.max(input.maximum)
  if (input.exclusiveMinimum !== undefined)
    inner = inner.min(input.exclusiveMinimum * (1 + Number.EPSILON))
  if (input.exclusiveMaximum !== undefined)
    inner = inner.max(input.exclusiveMaximum * (1 - Number.EPSILON))
  if (input.multipleOf !== undefined) inner = inner.step(input.multipleOf)

  return inner
}

function handleInteger(input: JSONSchema7 & { type: "integer" }): z.ZodNumber {
  let inner = handleCommon(input, z.number().int())

  if (input.minimum !== undefined) inner = inner.min(input.minimum)
  if (input.maximum !== undefined) inner = inner.max(input.maximum)
  if (input.exclusiveMinimum !== undefined)
    inner = inner.min(input.exclusiveMinimum + 1)
  if (input.exclusiveMaximum !== undefined)
    inner = inner.max(input.exclusiveMaximum - 1)
  if (input.multipleOf !== undefined) inner = inner.step(input.multipleOf)

  return inner
}

function handleString(input: JSONSchema7 & { type: "string" }): z.ZodString {
  let inner = handleCommon(input, z.string())

  if (input.minLength !== undefined) inner = inner.min(input.minLength)
  if (input.maxLength !== undefined) inner = inner.max(input.maxLength)
  if (input.pattern !== undefined)
    inner = inner.regex(new RegExp(input.pattern))

  switch (input.format) {
    case undefined:
    case null:
      break
    case "idn-email":
    case "email":
      inner = inner.email()
      break
    case "ipv4":
      inner = inner.ip({ version: "v4" })
      break
    case "ipv6":
      inner = inner.ip({ version: "v6" })
      break
    case "iri":
    case "uri":
      inner = inner.url()
      break
    case "date-time":
      inner = inner.datetime()
      break
    case "date":
    case "time":
    case "uuid":
      inner = inner[input.format]()
      break
    default:
      throwUnsupported(input.format, "as a string format")
  }

  return inner
}

function handleEnum(
  input: JSONSchema7 & { enum: JSONSchema7Type[] }
): InnerAny {
  if (input.enum.length === 0) return handleCommon(input, z.never())

  if (input.enum.every((x) => typeof x === "string"))
    return handleCommon(input, z.enum(input.enum as [string, ...string[]]))

  if (input.enum.length === 1)
    return handleCommon(input, z.literal(toZodPrimitive(input.enum[0])))
  return handleCommon(
    input,
    z.union(
      input.enum.map((v) => z.literal(toZodPrimitive(v)) as InnerAny) as [
        InnerAny,
        InnerAny,
        ...InnerAny[],
      ]
    )
  )
}

function handleArray(
  input: JSONSchema7 & { type: "array" }
): InnerArrayAny | InnerTupleAny {
  if (Array.isArray(input.items) && input.items.length > 0) {
    return handleTuple(input as Parameters<typeof handleTuple>[0])
  }

  const { items } = input
  let inner = z.array(
    items ? handleDef(items as JSONSchema7Definition) : z.any()
  )

  inner = handleCommon(input, inner)

  if (input.minItems !== undefined) inner = inner.min(input.minItems)
  if (input.maxItems !== undefined) inner = inner.max(input.maxItems)

  for (const key of ["uniqueItems", "contains"] as const) {
    if (input[key] !== undefined) throwUnsupported(key, "in an array")
  }

  return inner
}

function handleTuple(
  input: JSONSchema7 & {
    type: "array"
    items: [JSONSchema7Definition, ...JSONSchema7Definition[]]
  }
): InnerTupleAny {
  let inner: InnerTupleAny = handleCommon(
    input,
    z.tuple(input.items.map(handleDef) as [InnerAny, ...InnerAny[]])
  )

  if (input.additionalItems !== undefined)
    inner = inner.rest(handleDef(input.additionalItems))

  for (const key of ["uniqueItems", "contains"] as const) {
    if (input[key] !== undefined) throwUnsupported(key, "in a tuple array")
  }

  for (const key of ["minItems", "maxItems"] as const) {
    if (input[key] !== undefined && input[key] !== input.items.length)
      throwUnsupported(
        key,
        "in a tuple array (unless it exactly matches the number of 'items')"
      )
  }

  return inner
}

function handleRecord(
  input: JSONSchema7 & {
    type: "object"
    additionalProperties: JSONSchema7Definition
  }
) {
  const inner = handleCommon(
    input,
    z.record(handleDef(input.additionalProperties))
  )

  for (const key of [
    "maxProperties",
    "minProperties",
    "required",
    "properties",
    "patternProperties",
    "dependencies",
    "propertyNames",
  ] as const) {
    if (input[key] !== undefined)
      throwUnsupported(
        key,
        "in an object with 'additionalProperties' (i.e. a 'Record' type)"
      )
  }

  return inner
}

function handleObject(input: JSONSchema7 & { type: "object" }) {
  const required = input.required ?? []
  const inner: Record<string, InnerAny> = {}
  for (const [key, def] of Object.entries(input.properties ?? {})) {
    const innerProp = handleDef(def)
    inner[key] = innerProp
    if (!required.includes(key)) inner[key] = innerProp.optional()
  }

  for (const key of [
    "maxProperties",
    "minProperties",
    "patternProperties",
    "dependencies",
    "propertyNames",
  ] as const) {
    if (input[key] !== undefined)
      throwUnsupported(
        key,
        "in an object (expected to have either entirely statically defined " +
          "'properties' or entirely open-ended 'additionalProperties')"
      )
  }
  if (input.additionalProperties) {
    throwUnsupported(
      "additionalProperties",
      "in an object (expected to have either entirely statically defined " +
        "'properties' or entirely open-ended 'additionalProperties')"
    )
  }

  return handleCommon(input, z.object(inner))
}

function handleIntersection(
  input: JSONSchema7 & { allOf: JSONSchema7Definition[] }
): InnerAny {
  const firstDef = input.allOf[0]
  if (firstDef === undefined) return z.any()

  if (input.allOf.length === 1) return handleDef(firstDef)

  let inner = handleDef(firstDef)
  for (const def of input.allOf.slice(1)) inner = inner.and(handleDef(def))

  return inner
}

function handleUnion(
  input: JSONSchema7 & { anyOf: JSONSchema7Definition[] }
): InnerAny {
  const firstDef = input.anyOf[0]
  if (firstDef === undefined) return z.never()

  if (input.anyOf.length === 1) return handleDef(firstDef)

  return z.union(
    input.anyOf.map(handleDef) as [InnerAny, InnerAny, ...InnerAny[]]
  )
}

function handleCommon<T extends InnerAny>(
  input: JSONSchema7,
  incomingInner: T
): T {
  let inner = incomingInner

  if (input.description !== undefined) inner = inner.describe(input.description)
  if (input.default !== undefined)
    inner = inner.default(input.default) as unknown as T

  for (const key of ["$ref"] as const) {
    if (input[key] !== undefined) throwUnsupported(key)
  }

  return inner
}

function toZodPrimitive(value: JSONSchema7Type | undefined): z.Primitive {
  if (typeof value === "object" && value !== null)
    throwUnsupported(
      Array.isArray(value) ? "an array value" : "an object value",
      "as a constant/literal value"
    )

  return value
}

function throwUnsupported(key: string, context = ""): never {
  const keyString = key.includes(" ") ? key : `'${key}'`
  throw new TypeError(
    `${keyString} in JSONSchema7 is not supported by KurtSchema${
      context ? ` ${context}` : ""
    }`
  )
}
