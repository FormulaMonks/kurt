import type { Promisable } from "type-fest"

/**
 * This event represents an intermediate chunk in the {@link KurtStream} of
 * events from Kurt. Prior to the final {@link KurtResult} event, every bit
 * of text from the underlying LLM will be sent as a chunk.
 *
 * The typical use case for this event is to display the text to the user
 * as it is generated, to reduce the perceived latency of the system.
 */
export type KurtStreamEventChunk = { chunk: string }

/**
 * This event represents the final result of a call to Kurt, and will always
 * be the last event in the {@link KurtStream}.
 *
 * For a generation call that generated data, the `data` field will contain
 * the structured data that was generated by Kurt, of type `D`, and the `text`
 * field will contain the final text that was generated by Kurt.
 *
 * For a generation call that did not generate data, the `text` field will be
 * populated but the `data` field will be `undefined` (and the `D`
 * type parameter will be typed to contain `undefined` as a possible value).
 */
export type KurtResult<D = undefined> = {
  /**
   * A marker field which can be used to identify a `KurtResult` event
   * as distinct from other kinds of events emitted by a {@link KurtStream}.
   */
  finished: true

  /**
   * The final text that was generated by the underlying LLM.
   *
   * This will always be populated, even for calls that generated data.
   */
  text: string

  /**
   * The structured data that was generated by the underlying LLM, of type `D`.
   *
   * This will be `undefined` for calls that did not generate structured data.
   *
   * It will never be `undefined` for type instantiations wherein the
   * `D` type parameter doesn't include the `undefined` type as a possibility.
   *
   * Note that sometimes an LLM may generate additional structured data entries,
   * and if you want to access those, you should look at the `additionalData`
   * field for any entries that were generated beyond the first entry.
   */
  data: D

  /**
   * Additional structured data entries generated by the underlying LLM.
   *
   * This mechanism is used to represent "parallel tool calls" supported by
   * some LLMs, which helps optimize for the case where the LLM has enough
   * information to specify multiple tool calls in one step.
   *
   * The first call/entry generated by the LLM will be in the `data` field,
   * and this field will only hold further entries generated beyond the first.
   *
   * This field is optional, because not all LLMs may support parallel calls.
   *
   * The first entry is a separate field so that the application can have a
   * strongly-typed guarantee that at least one data entry will be generated.
   * Also, an application that doesn't want to support parallel calls can
   * easily ignore this field and only look at the `data` field.
   */
  additionalData?: D[]
}

/**
 * An event that can be emitted by a {@link KurtStream}.
 */
export type KurtStreamEvent<D = undefined> =
  | KurtStreamEventChunk
  | KurtResult<D>

type _AdditionalListener<D = undefined> = (
  event: KurtStreamEvent<D> | { uncaughtError: unknown }
) => void

/**
 * This class represents the result of a call to Kurt.
 *
 * It acts as an `AsyncIterable`, so that the caller can observe a stream of
 * events (with a common interface across any supported LLM).
 *
 * The events are buffered such that multiple listeners can all observe
 * the stream, without disrupting one anothers' view of events, such that
 * each listener will see exactly the same stream of events, regardless
 * of when each one started listening.
 *
 * It also exposes a `result` convenience getter for callers who are only
 * interested in the final result event.
 */
export class KurtStream<D = undefined>
  implements AsyncIterable<KurtStreamEvent<D>>
{
  private started = false
  private finished = false
  private seenEvents: KurtStreamEvent<D>[] = []
  private finalError?: { uncaughtError: unknown }
  private additionalListeners = new Set<_AdditionalListener<D>>()

  /**
   * Create a new result stream, from the given underlying stream generator.
   * @param gen - A well-formatted stream of events from the underlying LLM.
   */
  constructor(private gen: AsyncIterable<KurtStreamEvent<D>>) {}

  /**
   * Get the final event from the end of the result stream, when it is ready.
   * @returns A promise for the final event from the result stream.
   */
  get result(): Promise<KurtResult<D>> {
    return toFinal(this)
  }

  /**
   * Get each event in the stream (each yielded from this `AsyncIterable`).
   */
  async *[Symbol.asyncIterator]() {
    // If some other caller has already started iterating on this stream,
    // we can't let them consume from the same underlying generator, because the
    // multiple watchers would disrupt each others view of the generated items.
    //
    // So as a workaround, we have a mechanism to "watch as an additional
    // listener", where we return a new generator that will receive events
    // second-hand from this generator, with this generator being the only
    // one that listens to the
    if (this.started)
      for await (const event of this.watchAsAdditionalListener()) yield event

    this.started = true
    try {
      for await (const event of this.gen) {
        // Capture the event in our internal event history,
        // and push it to any additional listeners who are waiting.
        this.seenEvents.push(event)
        for (const listener of this.additionalListeners) listener(event)

        // We need to yield the event *AFTER* we've done the bookkeeping above,
        // because our caller may decide to stop calling the generator at
        // any time, and we wouldn't want that to break other listeners.
        yield event

        // If this is the final event, break out of the event-receiving loop.
        //
        // If we have a misbehaving underlying generator that has more events
        // after the finish event, we'll be ignoring those.
        if ("finished" in event) break
      }
    } catch (e) {
      // If we catch an error, we need to store the error and also
      // notify any additional listeners, so that each of them can stop
      // listening and throw the error to their outer caller.
      this.finalError = { uncaughtError: e }
      for (const listener of this.additionalListeners) listener(this.finalError)

      // Finally, we throw it to our own caller/listener.
      throw e
    } finally {
      // We need to make sure we mark the stream as finished, even in the
      // case where the stream had an error before receiving the final event.
      // This finished flag doesn't mark reception of a final event - it marks
      // the fact that the stream won't receive any further events.
      this.finished = true
    }
  }

  private async *watchAsAdditionalListener() {
    // First, catch up on any events we missed so far.
    for (const event of this.seenEvents) yield event

    // Now, if we have a final error, we need to throw it to our caller.
    if (this.finalError) throw this.finalError.uncaughtError

    // If we know that the stream is already finished, we can stop here and
    // avoid unnecessarily creating an actual listener mechanism.
    if (this.finished) return

    // To make this generator work, we need to set up a replaceable promise
    // that will receive the next event (or error) via the listener callback.
    let nextEventResolve: (value: Promisable<KurtStreamEvent<D>>) => void
    let nextEventReject: (reason?: unknown) => void
    const createNextEventPromise = () => {
      return new Promise<KurtStreamEvent<D>>((resolve, reject) => {
        nextEventResolve = resolve
        nextEventReject = reject
      })
    }
    let nextEvent = createNextEventPromise()

    // Set up an "additional listener" callback to receive events from the main
    // listener (the first to start consuming from the underlying generator).
    //
    // Each time we receive an event we're going to resolve (or reject)
    // the current promise, then we will replace the promise (and its
    // associated resolve/reject functions), using closures.
    const listener: _AdditionalListener<D> = (event) => {
      if ("uncaughtError" in event) nextEventReject(event.uncaughtError)
      else nextEventResolve(event)
      nextEvent = createNextEventPromise()
    }
    this.additionalListeners.add(listener)

    try {
      // Now our generator is as simple as waiting on the next promise,
      // over and over again, until we see the final event.
      while (!this.finished) {
        const event = await nextEvent
        yield event
        if ("finished" in event) break
      }
    } finally {
      // Make sure to remove our listener at the end, even in the case of error.
      this.additionalListeners.delete(listener)
    }
  }
}

async function toFinal<D = undefined>(
  stream: KurtStream<D>
): Promise<KurtResult<D>> {
  for await (const event of stream) {
    if ("finished" in event) {
      return event
    }
  }
  throw new Error(
    "KurtResult never sent a finish event (or an error). " +
      "This is a bug in the Kurt library that should be reported"
  )
}
